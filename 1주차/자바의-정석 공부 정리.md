# 자바의 정석

- [chapter 1. intro](#intro-주요-정리)
- [chapter 2. variable](#variable-주요-정리)
- [chapter 3. Operator](#operator-주요-정리)
- [chapter 4. 조건문과 반복문](#조건문과-반복문-주요-정리)


## intro 주요 정리

### 자바 언어의 특징
- 자바 언어는 운영체제에 독립적이다. (하지만, JVM은 운영체제에 종속적이다.)
- 객체지향 언어이다. (**주제**)
  > 당연한 말이지만, 객체지향 언어를 사용한다고 해서 객체지향 그리고 객체지향 프로그래밍이 되는 것이 아니다.
- 자동 메모리 관리(Garbage Collector) (그럼에도 불구하고, 메모리 누수가 필요하다.)
- 멀티 스레드를 지원한다.
- 동적 로딩을 지원한다. (load-time, runtime)

### JVM(Java Virtual Machine)
- 자바를 실행하기 위한 가상 머신, 자바 애플리케이션이 실행되려면 반드시 JVM이 필요하다.
- 즉, OS 위에 JVM이라는 가상 머신을 하나 더 올리고 그 위에 자바 애플리케이션이 실행된다.
- 컴파일되어 생성된 바이트 코드를 기계어로 해석 후 실행 
- 개념과 동작 과정 (**주제**)
  > 자세한 메모리 구조는 객체지향에서 다룰 예정


## variable 주요 정리

### 변수
- 단 하나의 `값`을 저장할 수 있는 메모리 공간

### 변수 초기화
- 변수를 사용하기 전 처음으로 값을 저장하는 것
- 메모리는 여러 프로그램이 공유하는 자원이기 때문에 다른 프로그램에 의해 저장된 쓰레기 값이거나 할당되지 않는 값을 꺼낼 수 있기 때문이다.

### 타입
- 기본형(primitive) : 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
- 참조형(reference) : 기본형을 제외한 나머지 타입, 객체의 `주소`를 저장한다.(값이 아니다.)

### 상수
- 변수와 마찬가지로 '값을 저장할 수 있는 공간'이지만, 변수와 달리 한 번 값을 저장하면 다른 값으로 변경할 수 없다.
- `final` 키워드를 사용한다.

> final은 변수, 메서드, 클래스에 각각 쓰일 수 있는데, 상수, 오버라이드 제한, 상속 제한으로 대응된다.

### 문자 리터럴과 문자열 리터럴
- 'A'와 같이 작은 따옴표로 문자 하나를 감싼 것을 '문자 리터럴'
- 두문자 이상을 큰 따옴표를 감싼 것을 '문자열 리터럴'

#### 추가
문자열 + any type -> 문자열 + 문자열로 치환된다.
any type + 문자열 -> 문자열 + 문자열로 치환된다.

### 문자형
문자형은 사실 문자가 아니라 `문자의 유니코드`가 저장된다. (컴퓨터는 애석하게도 숫자밖에 알지 못하기 때문이다.)
즉, `char c = 'a';`는 a의 유니코드는 65이기 때문에 c라는 변수에 65가 저장된다.
다시 생각해보면 char 타입의 변수 값에 숫자를 저장하면 그 숫자에 대응된 유니코드 문자를 표시할 수 있다는 것이다.


### ASCII
- 정보 교환을 위한 미국 표준 코드, 128개의 문자 집합을 제공하는 7bit 부호
- 아스키는 숫자 '0~9', 'a~z', 'A~Z'가 연속적으로 배치되어 있다는 특징이 있다.

### Unicode
- 인터넷의 발명으로 서로 다른 지역, 다른 언어를 사용하는 컴퓨터간의 문서 교환을 위해 만들어진 전 세계의 모든 문자를 하나의 문자집합으로 표현(하기 위해 노력)한 코드
- 16bit -> 21bit (여기서 확장된 영역을 보충 문자의 영역인데, char이 아닌 int 타입을 사용한다.)
- 유니코드에 포함시키고자 하는 문자들의 집합을 구성하고, 이 문자셋에 번호를 붙인 것이 유니코드 인코딩 (UTF-8, UTF-16, ...)
- Java는 UTF-16, (UTF-8과 UTF-16 인코딩 방식 모두 처음 128개의 문자가 ASCII와 동일하다.)

### 형 변환
- 변수 또는 상수의 타입을 다른 타입으로 변환하는 것
- 각 타입의 byte의 크기가 다르기 때문에 큰 범위의 타입 -> 작은 범위의 타입으로 형변환이 이루어질 때 값 손실이 발생한다. (물론, 그 값이 작은 범위의 타입이 커버할 수 있는 범위라면 값 손실은 발생하지 않는다.)
- 실수는 작은 범위의 타입(float)이 큰 범위의 타입(double)의 값을 커버하지 못하면 overflow로 무한대, underflow로 0이 된다.
- 실수형에서 정수형으로 타입으로 변환할 때, 소수점은 버린다.

#### 자동 형변환 규칙
- 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형 변환된다.
- 즉, 값의 범위가 작은 타입에서 큰 범위의 타입으로 형변환은 형변환 연산을 생략할 수 있다. (큰 범위 타입에서 작은 범위의 타입으로 변환할 땐 형변환 연산을 명시해야 한다.)
- boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.


## operator 주요 정리

### 연산자
- 연산을 수행하는 기호 (+, -. /, *, %, ++, -- 등)

> operator: 연산자, operand: 피연산자

### 연산자 종류
제발 이것만큼은 멈춰!


### 연산자 우선순위

> 조금 헷갈리는 것 위주로 작성했다.

- 시프트(<<) 연산자는 덧셈 연산자의 우선순위보다 낮다.
- BIT AND(&) 연산자는 비교(==)연산자보다 우선순위가 낮다.
- AND가 OR 보다 우선 순위가 높다.

#### Divided by zero
나눗셈으로 분모가 정수 0으로 들어가게 되면 error
실수 0.0으로 들어가게 되면 Infinity

> 실수는 표면적으로 완벽한 수 같지만, 메모리에선 소수를 완벽하게 표현할 수 없어서 그 값이 정확하지 않다. 그래서 0.0이 0이 아니고 0.0000000...003 이렇게 되어있다.


## 조건문과 반복문 주요 정리

### if-else

```java
if(조건식) {
  ...logic
}

if(조건식) {
  ...logic
}
else if(위 조건식이 아니고 다른 조건식) {

}
else {
  //위 조건식들 외에 나머지의 경우
}
```

@ 조건식은 항상 true | false

### switch

```java

switch(조건식) {
  case 값 :
    
    break;
    
  case 값2 :
    
    break;
    
  case 값 :
    
    break;
    
  default :
    ...
}

//
```
@ 조건식은 항상 정수 | 문자열
@ 값은 정수 상수와 문자열만 가능(jdk 1.7부터 문자열 가능해졌음)

### for
```java

for(int i = 1; i <= 5; i++) {
  ... logic
  
  /*
  1. i = 1로 할당, (초기화)
  2. i <= 5 보다 작은지 확인, (조건식)
  3. ...logic, (true면 logic 수행, false면 탈출)
  4. i ++, (증감식)
  5. i <= 5 보다 작은지 확인, (초기화는 다시 하지 않는다.)
  6. 반복
  */
}
```

### 새로운 for
```java

for([타입] 변수명 : [배열 : 컬렉션]) {
  //배열과 컬렉션은 나중에 다룬다.
}
```

### while

```java
while(조건식) {
  ...logic
  // 조건식이 **true인 동안**, while문 내부 로직을 수행한다.
}
```

만약, c/c++을 했었던 사용자가 i번 반복하는 코드를 java로 작성하면 이런 상황에 직면할수도 있다. 
```java
int i = 5;
while(i--) { ... } //error
```


자바는 0을 false로 취급하지 않는다. 이를 해결하려면 다음과 같이 작성해야한다.

```java

int i = 5;
while(i-- != 0) { ... }

```

### do-while
```java

do {
  ...logic
  /*
    첫 동작은 조건식과 상관없이 수행
    그 후부터 조건식 판별
  */
}while(조건식);
```

### break와 continue
- break: 자신이 포함된 가장 가까운 반복문을 벗어난다. if 문에서 보통 자주 사용
- continue: 반복문에서만 사용할 수 있고, continue를 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.


### 이름이 붙은 반복문
- break 문은 근접한 단 하나의 반복문만 벗어난다. 만약 중첩 for문이 여러개면서 특정 동작에서 for문 전체를 벗어나고 싶다면?
- 반복문에 이름을 명시해서 그 블록을 탈출하면 효과적일 것이다.

```java

Loop1 : for(int i = 0; i < 5; i++) {
  Loop2 : for(int j = 0; j < 5; j++) {
    if(i == j)  break Loop1; //loop1에 해당하는 반복문을 탈출함
  }
}

```

# 스터디 주제 참고
- [객체지향에 대해서 1](https://jeong-pro.tistory.com/95)
- [객체지향에 대해서 2](https://blog.metafor.kr/141)
- [JVM 동작 원리](https://steady-snail.tistory.com/67)
